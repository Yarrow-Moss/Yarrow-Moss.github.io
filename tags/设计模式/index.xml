<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>设计模式 on 亚罗.莫斯(Yaro.Moss)</title>
        <link>https://yaro-moss.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <description>Recent content in 设计模式 on 亚罗.莫斯(Yaro.Moss)</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>亚罗.莫斯(Yaro.Moss)</copyright>
        <lastBuildDate>Sat, 03 Jan 2026 00:00:56 +0800</lastBuildDate><atom:link href="https://yaro-moss.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>设计原则</title>
        <link>https://yaro-moss.github.io/p/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
        <pubDate>Sat, 03 Jan 2026 00:00:56 +0800</pubDate>
        
        <guid>https://yaro-moss.github.io/p/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
        <description>&lt;h3 id=&#34;一solid-原则核心五大原则&#34;&gt;&lt;strong&gt;一、SOLID 原则（核心五大原则）&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单一职责原则（Single Responsibility Principle, SRP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：一个类/模块/接口只负责一项职责（即只有一个改变的原因）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：避免类承担过多功能，降低复杂度和耦合度，方便维护和扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：将“用户数据处理”和“日志记录”分离为两个类，而非在一个类中混合实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开闭原则（Open/Closed Principle, OCP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：软件实体（类、模块、函数等）应&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：通过抽象和多态，允许在不修改原有代码的前提下，通过新增代码实现功能扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：定义接口 &lt;code&gt;Payment&lt;/code&gt;，通过实现 &lt;code&gt;WeChatPayment&lt;/code&gt;、&lt;code&gt;Alipay&lt;/code&gt; 等子类扩展支付方式，不修改接口本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;里氏替换原则（Liskov Substitution Principle, LSP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：子类可以完全替换父类，且不会影响程序的正确性。父类能做的事情，子类都能做，并且子类的行为要符合父类的预期，不能出现 “违背父类语义” 的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心要求&lt;/strong&gt;：子类必须实现父类的抽象方法，但不能覆盖父类的非抽象方法（除非是为了修正父类的错误，且行为保持一致）。 2. 子类可以增加自己的特有方法，但不能修改父类的方法语义。 3. 子类的方法参数要比父类的方法参数更宽松或相等（逆变）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：确保继承体系的可靠性，避免因子类行为不符合预期导致的错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反例&lt;/strong&gt;：“正方形”不应作为“矩形”的子类（若矩形允许修改宽高，正方形修改宽高时需保持宽高相等，违反父类契约）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;接口隔离原则（Interface Segregation Principle, ISP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：客户端不应该依赖它不需要的接口方法（即接口应细化，避免“胖接口”）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：让接口更专注，减少客户端与无关方法的耦合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：将 &lt;code&gt;Animal&lt;/code&gt; 接口拆分为 &lt;code&gt;Flyable&lt;/code&gt;、&lt;code&gt;Swimmable&lt;/code&gt; 等小接口，避免所有动物类被迫实现不相关的方法（如企鹅无需实现 &lt;code&gt;fly()&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依赖倒置原则（Dependency Inversion Principle, DIP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：高层模块不应依赖低层模块，两者都应依赖抽象（接口/抽象类）；抽象不依赖具体实现，具体实现依赖抽象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：降低模块间的耦合，使系统更灵活（如通过依赖注入实现解耦）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：高层模块 &lt;code&gt;UserService&lt;/code&gt; 依赖抽象接口 &lt;code&gt;UserRepository&lt;/code&gt;，而非具体实现类 &lt;code&gt;MySQLUserRepository&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二其他重要设计原则&#34;&gt;&lt;strong&gt;二、其他重要设计原则&lt;/strong&gt;
&lt;/h3&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;迪米特法则（Law of Demeter, LoD）/ 最少知识原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：一个对象应尽可能少地了解其他对象（即对象间交互应通过直接关联，避免依赖无关对象）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：减少对象间的耦合，降低修改带来的连锁反应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：避免通过 &lt;code&gt;A→B→C&lt;/code&gt; 的多层调用访问对象 &lt;code&gt;C&lt;/code&gt;，而是让 &lt;code&gt;A&lt;/code&gt; 直接依赖 &lt;code&gt;C&lt;/code&gt;（或通过中介者模式解耦）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;合成复用原则（Composite Reuse Principle, CRP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：优先使用组合（Has-A）或聚合（Contains-A）而非继承（Is-A）来实现代码复用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：避免继承带来的强耦合（子类依赖父类实现细节），提高灵活性（组合关系更易替换）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：通过将 &lt;code&gt;Logger&lt;/code&gt; 作为成员变量注入到类中，而非继承 &lt;code&gt;Logger&lt;/code&gt; 类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;封装变化点原则（Encapsulate What Varies）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：识别系统中可能变化的部分，将其封装在独立的模块或抽象中（如策略模式封装算法变化）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：隔离变化，使不变部分不受影响，便于扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：将“排序算法”封装为接口，具体算法（冒泡、快排）作为实现，客户端通过接口调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;针对接口编程而非实现（Program to an Interface, Not an Implementation）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：依赖抽象类型（接口/抽象类）而非具体类，降低对实现的依赖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：与依赖倒置原则相辅相成，提高代码的可替换性和扩展性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：声明变量为接口类型 &lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;/code&gt;，而非具体类 &lt;code&gt;ArrayList&amp;lt;String&amp;gt; list&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重用发布等价原则（REP, Reuse-Release Equivalence Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：软件模块的重用粒度应与发布粒度一致（即模块的版本控制和发布单位应与其可重用单位一致）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：确保复用的模块在发布时的一致性，避免版本冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;共同封闭原则（CCP, Common Closure Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：因相同原因变化的类应被封装在同一个模块中，无关变化的类应分离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：保持模块内聚性，使修改集中在相关模块中，减少影响范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这些原则是设计模式的基石，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;体现了依赖倒置和封装变化；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略模式&lt;/strong&gt;遵循开闭原则和接口隔离；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合模式&lt;/strong&gt;体现合成复用原则；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中介者模式&lt;/strong&gt;应用迪米特法则降低耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解并应用这些原则，能帮助设计出更健壮、易维护的系统，而设计模式则是这些原则的具体实践方案。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
